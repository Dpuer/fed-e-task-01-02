# 函数式编程与 JavaScript 性能优化

## 函数式编程（FP）

+ 与面向对象并列
+ 函数式编程是对运算过程的抽象
+ 函数式编程中的函数不是程序中的函数（方法），贰拾数学中的函数
+ 相同的输入始终要得到相同的输出（纯函数）
+ 函数式编程就是用来描述数据（函数）之间的映射
+ 优势：函数可以复用

### 函数是一等公民

+ 函数可以存储在变量中
+ 函数可以作为参数
+ 函数可以作为返回值

### 高阶函数

+ 可以把函数作为参数传递给另一个函数
+ 可以把函数作为另一个函数的返回结果
+ 意义：
    - 抽象可以帮我们屏蔽细节，只需要关注我们的目标
    - 高阶函数是用来抽象通用的问题

### 闭包

+ 可以在另一个作用域中调用一盒函数内部函数并访问到该函数的作用域中的成员
+ 本质：函数在执行的时候会放到一个执行栈上当函数执行完毕后，会从执行栈上移除，，**但是堆上的作用域成员因为被外部引用不能被释放**，因此内部函数依然可以访问外部函数的成员

### 纯函数
+ 相同的输入永远会得到相同的输出，而且没有任何可观察的副作用
+ 函数式编程不会保留计算中间的结果，所以变量是不可以变的（无状态的）
+ 我们可以把一个函数的执行结果交给另一个函数去处理
+ 优点：
    - 可缓存
    - 可测试
    - 并行处理

### 函数的副作用

副作用让一个函数变得不纯，所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，需要尽可能控制他们在可控范围内发生。

来源：
    + 配置文件
    + 数据库
    + 用户输入
    + ……

### 柯里化
+ 当一个函数有多个参数的时候可以先传递一部分参数调用它（这部分参数以后永远不变）
+ 然后返回一个新的函数接收剩余的参数，返回结果
+ 总结：
    - 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
    - 这是一种对函数参数的缓存
    - 让函数变得更灵活，让函数的粒度更小
    - 可以把多元函数转换成一元函数，可以组合使用函数的产生强大的功能

### 函数组合

+ 纯函数和柯里化很容易写出洋葱代码
+ 函数组合可以让我们把细粒度的函数重新组合成一个新的函数
+ 可以让函数可以最大限度的重用

#### 管道

+ 函数就想是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果
+ 函数组合默认从右到左执行

### Point Free

+ 不需要指明处理的数据
+ 只需要合成运算过程
+ 需要定义一些辅助的基本运算函数

### Functor(函子)

+ 容器：包含值和值得变形关系（函数）
+ 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理


## 性能优化

### 内存管理

+ 内存： 由可读写单元组成，标识一片可以操作的空间
+ 管理： 认为的去操作一片空间的申请、使用和释放
+ 内存管理： 开发者主动申请空间、使用空间、释放空间
+ 管理流程： 申请-使用-释放

### 垃圾回收与厂家GC算法

#### JavaScript中的垃圾

+ JavaScript中内存管理是自动的
+ 对象不再被引用时是垃圾
+ 对接不能从根上访问到时是垃圾

#### JavaScript中的可达对象

+ 可以访问到的对象就是可达对象
+ 可达的标准就是从根出发是否能够被找到
+ JavaScript中的根就可以理解为是全局变量对象

#### GC定义与作用

+ GC就是垃圾回收机制的简写
+ GC可以找到内存中的垃圾、并释放和回收空间
+ 算法就是工作时查找和回收所遵循的规则

#### 常见GC算法

+ 引用计数
+ 标记清除
+ 标记整理
+ 分代回收

##### 引用计数算法

+ 核心思想： 设置引用书，判断当前引用数是否为0
+ 引用计数器
+ 引用关系改变是修改引用数字
+ 引用数为0时立即回收
+ 优点：
    - 发现垃圾时立即回收
    - 最大限度减少程序卡顿时间
+ 缺点：
    - 无法回收循环引用的对象
    - 资源消耗大

##### 标记清除算法

+ 核心思想：分标记和清除两个阶段完成
+ 遍历所有对象找标记活动对象
+ 遍历所有对象清除没有标记对象
+ 回收相应空间
+ 优点：
    - 能解决循环引用的回收
+ 缺点：
    - 回收地址不连续，造成空间碎片化
    - 不会立即回收垃圾对象

##### 标记整理算法

+ 标记整理可以看做是标记清除的增强
+ 标记阶段的操作和标记清除一致
+ 清除阶段会先执行整理，移动对象位置
+ 优点：
    - 减少碎片化空间
+ 缺点：
    - 不会立即回收垃圾对象

### V8引擎的垃圾回收

#### 认识V8

+ V8是一款主流的JavaScript执行引擎
+ V8采用即时编译
+ V8内存设限（64位 <= 1.5G,32位 <= 800M）

#### V8垃圾回收策略

+ 采用分代回收的思想
+ 内存分为新生代、老生代
+ 针对不同对象采用不同算法

#### V8中常用GC算法

+ 分代回收
+ 空间复制
+ 标记清除
+ 标记整理
+ 标记增量

#### V8内存分配

+ V8内存空间一分为二
+ 小空间用于存储新生代对象（32M|16M）
+ 新生代指的是存活时间比较短的变量
+ 老生代对象存放在右侧老生代区域 （1.4G|700M）
+ 老生代对象就是指存活时间较长的变量

#### 新生代对象回收实现

+ 回收过程采用复制算法+标记整理
+ 新生代内存区分为两个等大小空间
+ 使用空间为From，空闲空间为To
+ 活动对象储存于From空间
+ 标记整理后将活动对象拷贝至To
+ From与To交换空间完成释放

#### 回收细节说明

+ 拷贝过程中可能出现晋升
+ 晋升就是将新生代对象移动至老生代
+ 一轮GC还存活的新生代需要晋升
+ To空间的使用率超过25%

#### 老生代对象回收实现

+ 主要采用标记清除、标记整理、增量标记算法
+ 首先使用标记清除完成垃圾空间的回收
+ 采用标记整理进行空间优化（触发晋升时）
+ 采用增量标记进行效率优化

#### 细节对比

+ 新生代区域垃圾回收使用空间换时间（新生代内存空间本身小）
+ 老生代区域垃圾回收不适合复制算法

### Performance工具

#### 为什么使用Performance

+ GC的目的是为了实现内存空间的良性循环
+ 良性循环的基石是合理使用
+ 时刻关注才能确定是否合理

#### Performance使用步骤

+ 打开浏览器输入目标地址
+ 进入开发人员面板，选择性能
+ 开启录制功能，访问具体界面
+ 执行用户行为，一段时间后停止录制
+ 分析界面中记录的内存信息

#### 内存问题的外在表现

+ 页面出现延迟加载或经常性暂停（频繁垃圾回收：通过内存变化图进行分析）
+ 页面持续性出现糟糕的性能（内存膨胀：在多数设备上都存在性能问题）
+ 页面的性能随时间延长越来越差（内存泄漏：内存使用持续升高）

#### 监控内存的几种方式

+ 浏览器任务管理器
+ Timeline时序图记录
+ 堆快照查找分离DOM
+ 判断是否存在频繁的垃圾回收

#### 什么事分离DOM

+ 界面元素存活在DOM树上
+ 垃圾对象时的DOM节点
+ 分离状态的DOM节点

#### 为什么确定频繁垃圾回收

+ GC工作时应用程序是停止的
+ 频繁且过长的GC会导致应用假死
+ 用户使用中感知应用卡顿
+ 方式
    - Timeline中频繁的上升下降
    - 任务管理器中数据频繁的增加减少

### 代码性能

#### 如何精准测试JavaScript性能

+ 本质上就是采集大量的执行样板进行数学统计和分析
+ 使用基于Benchmark.js的https://jsperf.com/完成

#### 慎用全局变量

+ 全局变量定义在全局执行上下文，是所有作用域链的顶端
+ 全局执行上下文一直存在于上下文执行栈，知道程序退出才会消失
+ 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

#### 关于闭包

+ 闭包是一种强大的语法
+ 闭包使用不当很容易出现内存泄漏
+ 不要为了闭包而闭包

#### JavaScript中的面向对象

+ JS不需要属性的访问方法，所有属性都是外部可见的
+ 使用属性访问方法只会增加一层重定义，没有访问的控制力